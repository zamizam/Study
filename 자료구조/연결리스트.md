# 연결 리스트 (Linked List)

## 개념
- 노드(Node)들이 포인터를 이용해 선형으로 연결된 자료구조.
- 각 노드는 데이터와 다음 노드를 가리키는 포인터를 가짐.

## 종류
| 종류           | 설명                                 |
|---------------|------------------------------------|
| 단일 연결 리스트 | 노드가 다음 노드만 가리킴               |
| 이중 연결 리스트 | 노드가 이전/다음 노드 모두 가리킴        |
| 원형 연결 리스트 | 마지막 노드가 첫 번째 노드를 가리킴      |

## 주요 연산 및 시간 복잡도
| 연산    | 설명                    | 시간 복잡도 |
|--------|------------------------|------------|
| 접근   | 특정 위치 노드 접근       | O(n)       |
| 삽입   | 노드 추가 (포인터 조작)    | O(1) (노드 위치 알고 있을 경우) |
| 삭제   | 노드 제거 (포인터 조작)    | O(1) (노드 위치 알고 있을 경우) |
| 탐색   | 값 찾기                   | O(n)       |

## STL 지원
| 이름          | 설명               |
|--------------|------------------|
| `std::list`  | 이중 연결 리스트     |
| `std::forward_list` | 단일 연결 리스트 |

## 장단점
### 장점
- 크기 제한이 없음.
- 중간 삽입/삭제가 빠름 (노드 위치 알고 있다면 O(1)).

### 단점
- 인덱스 접근이 불가능 → O(n).
- 메모리 사용량 증가 (포인터 추가 저장 필요).

## 실전 활용 예시
- 큐, 스택 등의 내부 구현.
- 메모리 할당 관리.
- Undo/Redo 기능 구현.

## C++ 예시 코드 (단일 연결 리스트)
```
#include <iostream>
#include <vector>
using namespace std;

struct Node
{
    int data;
    int next;  // 다음 노드의 인덱스 (-1이면 끝)
};

int main()
{
    vector<Node> list;

    // 노드 삽입
    list.push_back({10, 1});
    list.push_back({20, 2});
    list.push_back({30, -1});

    // 순회
    int cur = 0;
    while (cur != -1)
    {
        cout << list[cur].data << " ";
        cur = list[cur].next;
    }
    cout << endl;

    return 0;
}
```
### 특징
| 장점                              | 단점                       |
| ------------------------------- | ------------------------ |
| 메모리 자동 관리 (`vector`)            | 노드 삽입/삭제 시 인덱스 관리 필요     |
| CPU 캐시 효율 극대화 (`vector` 연속 메모리) | 삽입/삭제 시 빈 칸 처리 로직 필요 가능성 |
| 포인터 없는 안전한 연결 리스트 흉내            | 복잡한 구조에서는 관리 어려움         |
### 4. 실수 포인트 & 관리 팁
| 실수/주의             | 설명                                    |
| ----------------- | ------------------------------------- |
| 삭제 시 빈 칸 관리 필요    | 삭제된 노드는 vector에서 제거 불가, 빈 노드 처리 필요    |
| 삽입/삭제 시 인덱스 직접 관리 | `next` 필드를 수동 관리해야 함                  |
| 연결 고리 끊김 주의       | `next` 연결 실수 → 메모리 안심이지만 논리적 오류 발생 가능 |
| 메모리 누수 없음         | `vector` 관리, 별도 메모리 해제 불필요            |
