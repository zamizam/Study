# vector vs list

C++ STL의 대표 시퀀스 컨테이너인 `vector`와 `list`는 기능도 비슷하고 자주 비교되지만, 내부 구조와 사용 목적은 매우 다르다. 이 문서에서는 정렬 뿐만 아니라, 성능, 메모리, 접근 방식 등 다양한 측면에서 비교해본다.

---

## 1. 기본 구조 차이

| 항목 | `vector` | `list` |
|------|----------|--------|
| 자료구조 | 연속된 동적 배열 | 이중 연결 리스트 |
| 메모리 구조 | 연속된 heap 메모리 | 각 노드가 포인터로 연결됨 |
| 접근 방식 | 인덱스로 임의 접근 가능 (`[]`, `at`) | 임의 접근 불가, iterator로만 탐색 |
| 삽입/삭제 | 끝에서 빠름, 중간은 느림 | 중간 삽입/삭제에 강함 |
| 앞쪽 삽입/삭제 | 느림 (`insert(begin())`) | 빠름 (`push_front`, `pop_front`) |
| 캐시 효율 | 좋음 | 나쁨 |
| 메모리 오버헤드 | 낮음 | 높음 (포인터 2개 per 노드) |

#### 설명
- `vector`는 요소들이 연속된 메모리에 배치되므로, 인덱스를 통한 직접 접근이 가능하다.  
  → 메모리 주소만 계산하면 되기 때문에 `O(1)` 속도가 나옴  
- 반면 `list`는 각 요소가 포인터로 연결되어 있어 순차적으로 따라가야 하므로 `O(n)`  
- `vector`는 삽입/삭제 시 모든 뒤 요소를 밀거나 땡겨야 해서 느림  
- `list`는 노드 간 포인터만 수정하면 되므로 중간 삽입/삭제가 빠름  
- `vector`는 메모리가 연속되기 때문에 CPU 캐시 적중률이 높아 반복 탐색 시 더 빠름  
---

## 2. 반복자(Iterator) 안정성

| 상황 | `vector` | `list` |
|------|----------|--------|
| 요소 추가 시 | capacity 초과 시 모든 iterator 무효화 | iterator 유지됨 |
| 요소 삭제 시 | 이후 요소 iterator 모두 무효화 | 삭제된 노드만 무효화됨 |
| 삽입/삭제 많은 구조에 적합? | ❌ | ✅ |

#### 설명
- `vector`는 capacity를 초과하면 전체 데이터를 새 메모리 블록으로 복사해 재할당하기 때문에 기존 iterator는 모두 무효화됨  
- 삭제 시, 뒤에 있는 모든 요소의 인덱스가 변경되므로 이후 iterator도 무효화  
- `list`는 포인터 기반이기 때문에 노드가 이동하더라도 나머지 노드의 위치는 변하지 않음  
  → 삽입·삭제가 반복되어도 iterator 안정성이 보장됨  

---

## 3. 성능 비교 요약

| 작업 | `vector` | `list` |
|------|----------|--------|
| `push_back` | O(1) 평균 | O(1) |
| `insert` (중간) | O(n) | O(1) (iterator 기준) |
| `erase` (중간) | O(n) | O(1) (iterator 기준) |
| 임의 접근 | O(1) | O(n) |
| 반복 탐색 | 빠름 | 느림 |
| 메모리 사용량 | 효율적 | 포인터 오버헤드 존재 |

---

## 4. 정렬과 내부 구현 차이

### sort 사용 방식

| 컨테이너 | 정렬 방식 | 설명 |
|----------|------------|------|
| `vector` | `std::sort(v.begin(), v.end())` | random access iterator 필요 |
| `list` | `l.sort()` | 멤버 함수. 내부 병합 정렬 사용 |

### 정렬 알고리즘 차이

| 항목 | `vector` (`std::sort`) | `list` (`list.sort()`) |
|------|------------------------|-------------------------|
| 알고리즘 | Introsort (quick + heap + insertion) | Merge sort |
| 정렬 안정성 | 불안정 | 안정 정렬 (stable) |
| 이동 비용 | 값 자체를 이동 (copy/move) | 포인터만 재배치 |
| 대용량 구조체에 적합? | 불리함 | 유리함 |

---

## 5. 사용 예시 및 선택 기준

## 5. 사용 예시 및 선택 기준

| 조건 | 추천 컨테이너 | 이유 |
|------|----------------|------|
| 빠른 인덱스 접근이 필요한 경우 | `vector` | 요소가 연속된 메모리에 저장되므로, 인덱스를 통한 O(1) 직접 접근이 가능하다. |
| 중간 삽입/삭제가 잦은 경우 | `list` | 포인터 연결만 변경하면 되므로, 중간 요소 추가/삭제 시 다른 요소 이동이 발생하지 않는다. |
| 구조체 복사 비용이 큰 경우 | `list` | `list.sort()` 등에서 값 자체를 복사하지 않고 포인터만 재배열하므로 비용이 절감된다. |
| 메모리 사용량을 최소화해야 하는 경우 | `vector` | 오직 데이터만 저장하는 구조로, 포인터 등 메타데이터가 없어 오버헤드가 적다. |
| 정렬 안정성이 중요한 경우 | `list` | `list.sort()`는 stable sort이며, 같은 값이 들어올 경우 원래 순서를 유지한다. |
| 다양한 STL 알고리즘과 함께 쓸 경우 | `vector` | `std::sort`, `std::binary_search` 등 대부분의 표준 알고리즘이 random access iterator를 요구하며, `vector`가 이를 만족한다. |


---

## 6. 예제 코드

```cpp
// vector 정렬
std::vector<int> v = {3, 1, 4};
std::sort(v.begin(), v.end());

// list 정렬
std::list<int> l = {3, 1, 4};
l.sort(); // 내부 병합 정렬
```
---
## 7. 요약 키워드

- `vector` :  
  연속된 메모리 공간을 사용해 **빠른 인덱스 기반 접근(O(1))** 이 가능하며,  
  대부분의 표준 알고리즘과 호환된다.  
  **삽입/삭제가 드물고, 데이터 순회나 정렬 중심의 처리에 적합**하다.

- `list` :  
  각 요소가 포인터로 연결된 이중 연결 리스트로 구성되어 있어  
  **중간 삽입/삭제에 최적화(O(1, iterator 기준))** 되어 있다.  
  요소 이동 없이 포인터만 바꾸는 `sort()` 를 지원하므로  
  **복사 비용이 큰 구조체, 안정 정렬이 필요한 상황에서 유리**하다.

