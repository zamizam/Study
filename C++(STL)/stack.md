## stack이란?

- **LIFO(Last-In, First-Out)** 구조의 컨테이너 어댑터  
- STL의 `stack`은 `vector`, `deque`, `list` 등을 기반으로 동작 (기본: `deque`)  
- 가장 나중에 들어간 요소가 가장 먼저 나옴  
- 내부 컨테이너의 `back()`을 top으로 사용  

---

## stack 주요 함수 정리

### 요소 접근

| 함수 | 설명 |
|------|------|
| `s.top()` | 가장 위(top)의 요소 참조 (삭제 X) |

### 삽입 및 삭제

| 함수 | 설명 |
|------|------|
| `s.push(val)` | 요소 추가 (`top`에 쌓음) |
| `s.pop()` | `top` 요소 제거 (반환값 없음) |
| `s.emplace(args)` | 직접 생성하여 요소 추가 (복사/이동 생략) |

### 기타

| 함수 | 설명 |
|------|------|
| `s.size()` | 요소 개수 |
| `s.empty()` | 비었는지 확인 |
| `s.swap(other)` | 다른 `stack`과 내부 요소 교환 |

---

## stack 사용 시 주의할 점

- **반복자(iterator)** 제공하지 않음 → 직접 순회 불가  
- `pop()`은 반환값이 없음 → `top()` 먼저 사용 후 `pop()`  
- `stack<T>`는 기본적으로 **`deque<T>`**를 내부 컨테이너로 사용  
- 필요 시 다른 컨테이너로 대체 가능: `vector`, `list` 등

---

## stack 성능 관련
- `stack`은 **LIFO(Last-In, First-Out)** 구조로, 항상 마지막에 삽입한 요소만 접근 가능하므로  
  **삽입(push)과 삭제(pop)가 매우 단순하고 빠름**
- 내부적으로는 일반적으로 **후방 삽입에 최적화된 컨테이너(deque 등)**를 사용하여  
  **O(1)** 시간 복잡도로 `push`, `pop`, `top` 연산이 가능함
- `stack`은 반복자(iterator)를 제공하지 않고, 중간 요소에 접근할 수 없기 때문에  
  **불필요한 기능이 제거된 가벼운 구조**로, **단순하고 예측 가능한 성능**을 가짐
- 구조적으로 스택 깊이가 얕고, 연산이 빈번한 경우에도 **안정적인 성능 유지**
- `top()` 호출은 내부 컨테이너의 마지막 요소 참조와 동일하므로 **참조 비용이 거의 없음**
- 메모리 재할당이나 복사 비용은 내부 컨테이너에 따라 달라지지만, 일반적으로는  
  삽입/삭제가 빈번해도 **성능 저하 없이 처리 가능**

> 요약: `stack`은 중간 접근 없이 오직 마지막 요소만 다루기 때문에, 구조적으로 매우 효율적이며  
> 일반적인 사용 패턴에서는 **성능 병목이 거의 없는 자료구조**이다.



## stack 내부 구조 관련 (내부 컨테이너 선택에 따른 영향)

- `std::stack`은 내부 컨테이너에 따라 간접적인 성능 차이가 발생할 수 있음
-  기본 컨테이너는 `deque`이지만, 필요에 따라 `vector`, `list` 등으로 대체 가능 
    - `deque` (기본): 빠른 삽입/삭제, 양쪽 지원  
    - `vector`: 연속 메모리 구조 → 캐시 효율 높음, 후방 push/pop에 최적화  
    - `list`: 포인터 기반 → 중간 삽입/삭제 반복 시 유리  

  
- `vector` 기반 stack은 메모리 재할당 이슈는 있지만, 작고 빈번한 push/pop 구조에서 효율적
```cpp
std::stack<int, std::vector<int>> s; // vector 기반 stack
```
| 내부 컨테이너 | 특성 |
|---------------|------|
| `deque` (기본) | 빠른 push/pop, 양쪽 지원, 안정적인 성능 |
| `vector` | 연속 메모리 → 캐시 효율 ↑, 후방 push/pop 최적화 (단, 재할당 발생 가능성 있음) |
| `list` | 포인터 기반 → 중간 삭제 등에서 참조 안정성 ↑ (하지만 캐시 효율 ↓) |

> 위 비교는 **`stack<T, Container>` 형태로 사용할 때의 내부 컨테이너 성능**에 대한 것

---

```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;

    s.push(10);
    s.push(20);
    s.push(30);

    std::cout << "Top: " << s.top() << std::endl; // 30
    s.pop(); // 30 제거
    std::cout << "Top: " << s.top() << std::endl; // 20

    return 0;
}
```
---
## 요약 키워드

- `stack` : LIFO 구조 (후입선출)  
- `push`, `pop` : 삽입/제거  
- `top` : 최상단 요소 참조  
- `emplace` : 복사 없이 직접 생성  
- 반복자 없음, 내부는 `deque` 기반 (또는 `vector`, `list`)  

---

## 연관 키워드

- [`queue`](./queue.md) : FIFO 구조, 앞에서 꺼내고 뒤에 삽입  
- [`deque`](./deque.md) : stack의 기본 컨테이너, 양쪽 접근 지원  
- [`vector`](./vector.md) : 후방 삽입에 강한 동적 배열  
- [`list`](./list.md) : 양방향 연결 리스트, 중간 삽입/삭제 최적화  
- [`priority_queue`](./priority_queue.md) : 우선순위 기반의 힙 구조 큐  

