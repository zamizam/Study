## 프로그래머스 Lv.2 카펫
최근 코딩 테스트를 많이 보았는데, 면접 중에 코테 푼 것을 설명하라는 질문을 받았었다.
당시 푼 코테는 시간제한이 있었다. 스트링은 대충 기억이 나서 한줄한줄 설명했는데 상대방이 이해하도록 얘기하진 못한 것 같았다...(표정이 무슨 말이지...) 싶은... 차라리 질문을 해주시지 그냥 듣고만 계셨다.

다음 문제들은 시간 제한으로 코드도 길어졌고 변수명도 코테 풀 때에는 자료형이나 대충 자료구조 그 자체 이름을 사용하곤 했다. 막상 설명하라고 닥쳤을 때에는 내 머리속 지우개처럼 내가 짠 코드조차 뭐였더라 하고 막히고 만다.

기억을 해내려고 쩔쩔매고 그 와중에 한줄한줄 다시 읽기엔 코드가 길 수도 있다. 그리고 사람은 당황하면 뭐든 엉망진창이 된다. 그것을 사전에 막고자 변수명도 잘 짓는 습관을 들여야하고, 문제 풀이 방식에도 언제 돌발 질문이 들어올지 모르니 코드 짜는 방식에 항상 대비하고 있어야 한다.

당시 두 번째 문제는 나름 자료구조를 써가며 풀었다. 마지막 문제는 자료구조도 아니라 그냥 나름 아이디어를 써서 풀었다. 사실 알고리즘이 필요없을지도 모른다. 순간적으로 특별한 알고리즘을 순간적으로 생각해내지 못할지 모른다.

이번 문제의 풀이가 비슷했다. 완전 탐색을 어떻게 하면 가장 효율적으로 할 수 있을까? 생각해보았다. 

나름 생각해본 것은 가운데 노란색으로 생기는 부분의 가로, 세로 길이에 따른 일정의 규칙이 생긴다. 그래서 노란색의 가로,세로 길이가 나올 수 있는 경우를 소인수 분해하였다.

그리고 브라운의 갯수는 노란색의 길이에 따라 요구 조건을 맞출 수 있따. 옐로우 최종 길이 즉, (가로 + 2) x ( 세로 + 2 )가 브라운의 총 갯수를 만족할 경우 문제의 조건을 만족한다.

근데 글로 적어도 이게 제대로 된 설명이 된지 모르겠다.

다른 사람들의 풀이를 보았는데, 내 입장에선 뭐지 하드코딩? 이런 느낌이 들었다. 하지만 다른 사람들도 나름대로 일정 규칙의 풀이를 가지고 푼 것 같아 보였다. 이 것이 굳이 하드코딩이 아닐지 모른다. 각자만의 풀이가 존재한 것 이다. 

언젠가 코딩 테스트 설명하라는 질문을 다시 받는다면, 아니 누군가 내 코드에 대해 질문을 한다면 내 알고리즘을, 내 풀이를 잘 설명할 수 있게되면 좋겠다.

## 문제 설명
Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.
| 갈 | 갈 | 갈|
| ---| --- |--- |
| 갈 | 노 | 갈 |
| 갈 | 갈 | 갈

Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.

Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.

## 제한 사항
- 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
- 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
- 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.

## 입출력 예
| brown | yellow | return|
| ---| --- |--- |
| 10 | 2 | 	[4, 3] |
| 8 |	1 |	[3, 3] |
| 24	| 24 |	[8, 6] |

## 풀이
```
#include <string>
#include <vector>
#include <iostream>

using namespace std;

vector<int> solution(int brown, int yellow) {
    vector<int> answer;
    
    vector<vector<int>> vYellowArr;
    
    int x = 1;
    int y = yellow;
    while(1)
    {
        if( x > 2499 || x > yellow ) break;
        
        if( yellow % x == 0 )
        {
            vector<int> vArr;
            vArr.push_back(x);
            
            y = yellow / x;
            vArr.push_back(y);
            
            vYellowArr.push_back(vArr);
        }
        
        x++;
        if( x >= y ) break;
    }
    
    int nTotal = brown + yellow;
    
    for(int i = 0; i < vYellowArr.size(); i++)
    {
        vector<int> vArr = vYellowArr[i];
        
        //cout << vArr[0] << " " << vArr[1]<< endl;
        int y = vArr[0];
        int x = vArr[1];
        
        if( nTotal == (x+2) * (y+2))
        {
            answer.push_back(x+2);
            answer.push_back(y+2);
            
        }
    }
    
    
    return answer;
}
```
