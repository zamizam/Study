## 동적 계획법(Dynamic Programming, DP)
복잡한 문제를 여러 개의 작은 부분 문제로 나눠서 푸는 최적화 알고리즘.

즉 큰 문제를 작은 문제로 나누고, 그 결과를 재사용하여 전체 문제를 해결하는 방법으로 "작은 문제 → 큰 문제"로 확장, 중복 계산은 피함.

이전 결과를 저장해가며 전체 문제를 푸는 기법 -> 메모이제이션(Memoization)

## 메모이제이션(Memoization)
한 번 계산한 결과를 저장해두고, 같은 계산이 필요할 때는 다시 하지 않고 저장된 값을 사용하는 기법

예) 피보나치 수열을 재귀로 계산할 경우 -> 한 번 계산한 값은 배열에 저장해서 재사용

### 구현 방식
#### 1. Top-Down

재귀 + 메모이제이션 
```
int dp[100]; // 0으로 초기화 -> dp[n] 배열이 캐시 역할
int fib(int n) // fib(n) 호출 시 이미 값이 있으면 재귀 탐색 X
{
    if (n <= 1) return n;
    if (dp[n] != 0) return dp[n];          // 이미 계산된 경우
    return dp[n] = fib(n - 1) + fib(n - 2); // 처음 계산 시 저장
}
```
#### 2. Bottom-Up
메모이제이션은 아니지만 비슷한 캐싱 역할.

한 번 계산된 값으로 다음 값을 만들어냄 (반복문)
```
int fib(int n)
{
    int dp[100];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[n];
}
```
### 메모이제이션의 핵심 장점
| 장점          | 설명                       |
| ----------- | ------------------------ |
| ✅ 중복 계산 제거  | 시간 복잡도를 **지수 → 선형**으로 감소 |
| ✅ 구현 간단     | 탑다운 방식은 간결하고 직관적         |
| ✅ 직관적 문제 접근 | 점화식이 안 떠오를 때 유용          |
#### 탑다운 vs 바텀업 비교
| 방식      | 구현 특징         | 장점         | 단점           |
| ------- | ------------- | ---------- | ------------ |
| **탑다운** | 재귀 호출 + 캐시 배열 | 구현 쉬움      | 호출 스택 많으면 느림 |
| **바텀업** | 반복문 + 테이블 갱신  | 속도 빠르고 안정적 | 점화식 미리 알아야 함 |
#### 캐시 자료구조 선택 팁
| 상황                  | 사용 자료구조                 |
| ------------------- | ----------------------- |
| 인덱스가 숫자 (0 ≤ i ≤ N) | `vector<int>`, 배열       |
| 인덱스가 조합/문자열 등       | `unordered_map<string>` |

## 문제 예시
### 문제: 계단 오르기
한 번에 1칸 또는 2칸 계단을 오를 수 있다.
총 n개의 계단이 있을 때, 계단을 오르는 방법의 수를 구하라.
단, 연속해서 3칸은 못 오른다 (예: 1칸 + 1칸 + 1칸은 불가능)

- 입력:
정수 n (1 ≤ n ≤ 1000)

- 출력:
계단을 오를 수 있는 경우의 수 (정수)
