## Rabin-karp Algorithm(라빈 카프 알고리즘)
string 문자열 탐색 알고리즘에는 대표적으로 1. KMP 2. Rabin-karp 3. Naive 4. Boyer Moore  등이 있다.

코딩 테스트를 본다면 반드시 문자열 탐색 문제는 하나씩은 꼭 나온다.
이때 레벨이 조금 올라간다면 분명 시간복잡도에서 많이 실패를 맛 볼 것이다.

실제로 한 문제에서 엄청난 문자열을 비교하게 되었는데 2초 내에 진입해야하는 엄청난 장벽에 부딪혔다. 

나름 알고있는 알고리즘을 쓰려고 해도 쉽지 않았던 적도 있다. 하지만 알고리즘을 알고 있으면 활용이 가능하다.

그 중 라빈 카프, KMP는 꼭 알아두면 좋을 것 같아서 가져왔다.

### Rabin-karp Algorithm(라빈 카프 알고리즘) 란?
해싱(Hashing)을 사용해서 문자열의 특정 패턴을 가지고 해시값으로 변환하여 문자열을 탐색하는 방식이다.

예를 들어,

- 비교 문자열 : abbaaa 
- 비교할 문자열 : aaaabaaaaaa 

이 있다고 가정한다면 비교 문자열을 해시값으로 변환하여 비교할 문자열의 일부분을 가져와 해시값으로 변환해가며 탐색한다.

abbaaa가 해시값으로 12345 라고 가정한다면,

aaaabaaaaaa를 비교 문자열의 길이 만큼의 부분을 가져와 해시값으로 변환하며 비교한다.

문자열의 길이가 6 이므로, 먼저 aaaaba를 가져와 해시값으로 변환하여 일치 여부를 판단하고 아니면 맨 앞자리의 문자의 해시값을 제거한 뒤,
뒤에 이어질 문자으 시값을 추가하는 식으로 계산한다.
aaaaba가 23456 의 해시값을 가진다 친다면, 12345와 일치하지 않으므로 가장 앞자리 문자의 해시값을 제거하고 뒷자리 해시값을 계산하여 
차례대로 aaabaa의 해시값을 계산 및 비교한 뒤 일치할 때까지 찾아간다. 

이를 롤링 해시(Rolling Hash)라고 한다.


### 문제점
라빈 카프 알고리즘을 이용하면 문자열 탐색 속도는 상대적으로 빠르지만, 해시 충돌(Hash Collsion)이 발생할 수 있다.

해시 충돌은 해싱에서 나타나는 문제로, 해시값으로 변환했을 때 해시값이 중복으로 있을 경우를 말한다. 


따라서, 두 번째 문제점은 최악의 경우에 같은 문자의 반복이 된다면 
비교할 문자열의 길이가 N이고 비교 문자열의 길이가 M일 경우에 O(NM)이라는 시간복잡도가 나타난다.

이 의미는 'aaaaaaaaa'가 비교할 문자이고 비교 패턴 문자가 'aaa'일 경우를 말한다.

이렇게 되면 단순 비교가 많이 발생하기 때문이다.

### 시간 복잡도
하지만, 최악의 경우가 발생하지 않는다는 전제가 있다면

평균적으로 처음 패턴 만큼 해싱값으로 변환하는데 M만큼 소요되고,

문자탐색 시 N-M+1 + M 만큼 소요되기 때문에  N이 되어 O(M+N)이라고는 하는데 자료마다 달라서 확실하진 않다;;

이 부분은 좀더 찾아봐야할 듯

### 알고리즘 규칙은 다음과 같다.
```
d = 10;         // 가중치(?)
n = t.length    //문자 길이
m = p.length    //패턴 길이
h = dm-1 mod q   
p = 0
t0 = 0
for i = 1 to m
    p = (dp + p[i]) mod q
    t0 = (dt0 + t[i]) mod q
for s = 0 to n - m
    if p = ts
        if p[1.....m] = t[s + 1..... s + m]
            print "pattern found at position" s
    If s < n-m
        ts + 1 = (d (ts - t[s + 1]h) + t[s + m + 1]) mod q
```

