## 프로그래머스 레벨 5 방의 개수
원점(0,0)에서 시작해서 아래처럼 숫자가 적힌 방향으로 이동하며 선을 긋습니다.
<img width="542" height="540" alt="image" src="https://github.com/user-attachments/assets/159d5f7a-6ce4-4dac-bf7d-15daa279f57c" />
ex) 1일때는 오른쪽 위로 이동

그림을 그릴 때, 사방이 막히면 방하나로 샙니다.
이동하는 방향이 담긴 배열 arrows가 매개변수로 주어질 때, 방의 갯수를 return 하도록 solution 함수를 작성하세요.

### 제한사항
* 배열 arrows의 크기는 1 이상 100,000 이하 입니다.
* arrows의 원소는 0 이상 7 이하 입니다.
* 방은 다른 방으로 둘러 싸여질 수 있습니다.

### 입출력 예
| arrows	| return |
| --- | ---|
|[6, 6, 6, 4, 4, 4, 2, 2, 2, 0, 0, 0, 1, 6, 5, 5, 3, 6, 0]	| 3|

### 입출력 예 설명
<img width="590" height="564" alt="image" src="https://github.com/user-attachments/assets/9ed4c4ae-2b0d-450a-8162-4d623cb8cd89" />

* (0,0) 부터 시작해서 6(왼쪽) 으로 3번 이동합니다. 그 이후 주어진 arrows 를 따라 그립니다.
* 삼각형 (1), 큰 사각형(1), 평행사변형(1) = 3

## 문제 풀이
```
#include <string>
#include <vector>
#include <unordered_set>

using namespace std;

//8방향
const int dx[8] = { 0,1,1,1,0,-1,-1,-1};
const int dy[8] = { 1,1,0,-1,-1,-1,0,1};

struct stPoint
{
    int x,y;
    bool operator == (const stPoint& other ) const
    {
        return x == other.x && y == other.y;
    }
    
    struct Hash
    {
        size_t operator()(const stPoint& p) const
        {
            return hash<long long>()(((long long)p.x << 32 |(unsigned int)p.y));
        }
    };
    
};
       

//간선
struct stEdge{
    
    stPoint from, to;
    
    bool operator == (const stEdge& other ) const
    {
        return (from == other.from && to == other.to) || (from == other.to && to == other.from);
    }
    
    struct Hash
    {
        size_t operator() (const stEdge& e) const
        {
            size_t h1 = stPoint::Hash()(e.from);
            size_t h2 = stPoint::Hash()(e.to);
            return h1 ^ (h2 << 1 );
        }
    };
    
};

int solution(vector<int> arrows) {
    int answer = 0;
    
    unordered_set<stPoint, stPoint::Hash> visitedPoints;
    unordered_set<stEdge, stEdge::Hash> visitedEdges;
    
    stPoint cur = {0, 0};
    visitedPoints.insert(cur);
    int roomCount = 0;
    
    for(int dir : arrows )
    {
        for( int i = 0; i < 2; i++)
        {
            stPoint next = {cur.x + dx[dir], cur.y + dy[dir]};
            stEdge forward = {cur, next};
            stEdge backward = {next, cur};
            
            if( visitedPoints.count(next) && visitedEdges.count(forward) == 0 )
            {
                //새로운 간선, 방생성
                roomCount++;
            }
            
            visitedPoints.insert(next);
            visitedEdges.insert(forward);
            visitedEdges.insert(backward);
            
            cur = next;
            
        }
    }
    answer = roomCount;
    return answer;
}
```
```
정확성  테스트
테스트 1 〉	통과 (0.07ms, 4.16MB)
테스트 2 〉	통과 (0.31ms, 4.14MB)
테스트 3 〉	통과 (0.58ms, 4.21MB)
테스트 4 〉	통과 (1.41ms, 4.22MB)
테스트 5 〉	통과 (12.29ms, 7.11MB)
테스트 6 〉	통과 (91.15ms, 23MB)
테스트 7 〉	통과 (8.53ms, 6.51MB)
테스트 8 〉	통과 (67.49ms, 21.3MB)
테스트 9 〉	통과 (119.05ms, 34.3MB)
```

