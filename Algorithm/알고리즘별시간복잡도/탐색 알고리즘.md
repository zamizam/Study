# 탐색 알고리즘
| 탐색 목적               | 알고리즘                  | 삽입          | 삭제        | 접근 (탐색/Top)           | 전체 순회         | 특징 키워드                  |
| ------------------- | --------------------- | ----------- | --------- | --------------------- | ------------- | ----------------------- |
| 정확한 값/위치 탐색 (정렬 기반) | AVL Tree              | O(logN)     | O(logN)   | O(logN)               | O(N)          | 항상 균형, 탐색 빠름, 삽입/삭제 느림  |
|                     | Red-Black Tree        | O(logN)     | O(logN)   | O(logN)               | O(N)          | 느슨한 균형, 삽입/삭제 빠름, 실무 표준 |
|                     | B-Tree / B+ Tree      | O(logN)     | O(logN)   | O(logN)               | O(N)          | 디스크 최적, 대용량 인덱스         |
| 우선순위 기반 탐색          | Heap / Priority Queue | O(logN)     | O(logN)   | O(1) (Top)            | O(N logN)     | 우선순위 Top 빠름, 전체 탐색 비효율  |
| 구간 기반 최적화           | 슬라이딩 윈도우              | O(1) (이동)   | O(1) (이동) | O(1) (상태 유지)          | O(N)          | 구간 이동 효율, 동적 유지         |
|                     | Prefix Sum (누적합)      | O(N) (전처리)  | -         | O(1) (쿼리)             | O(N)          | 구간 합 쿼리 최적, 합 외 불가      |
| 문자열 패턴 탐색           | KMP                   | O(M) (pre)  | -         | O(N + M)              | O(N)          | 실패 테이블, 항상 안정적          |
|                     | Rabin-Karp            | O(1)        | -         | O(N + M) 평균, 최악 O(NM) | O(N)          | 해시 기반, 충돌 가능, 빠름/불안정    |
|                     | Aho-Corasick          | O(총 패턴 길이)  | -         | O(N + 총 패턴 길이)        | O(N)          | Trie+실패링크, 다중 패턴 동시 탐색  |
| 그래프 탐색              | BFS / DFS             | O(1) (큐 삽입) | O(1)      | O(1) (탐색 노드 접근)       | O(N + E)      | 그래프 탐색 기본, 너비/깊이 우선     |
|                     | Dijkstra (Heap 기반)    | O(logV)     | O(logV)   | O(1) (Top)            | O(E + V logV) | 최단 거리, 최소 힙 사용          |
|                     | A\* (Heap + 휴리스틱)     | O(logV)     | O(logV)   | O(1) (Top)            | O(E + V logV) | 최단 경로 + 휴리스틱, 경로 탐색 최적  |
| 키값 매칭               | Hash Table / Hash Set | O(1) 평균     | O(1) 평균   | O(1) 평균               | O(N)          | 정렬 불필요, 정확 매칭 최적        |
| 접두사 탐색              | Trie                  | O(L)        | O(L)      | O(L)                  | O(N \* L)     | 접두사 탐색 최적, 자동완성, 메모리 부담 |


# 알고리즘 → 자료구조 → 연산 복잡도 → 공간 복잡도 → 키워드
| 알고리즘           | 자료구조              | 삽입         | 삭제      | 접근 / 탐색               | 공간 복잡도     | 키워드                       |
| -------------- | ----------------- | ---------- | ------- | --------------------- | ---------- | ------------------------- |
| 이진 탐색          | 배열 (정렬)           | -          | -       | O(logN)               | O(N)       | 정렬 필요, 인덱스 기반 탐색          |
| 이진 탐색 트리 (BST) | 이진 탐색 트리 (BST)    | O(N) 최악    | O(N) 최악 | O(N) 최악               | O(N)       | 비균형 가능, 최악 O(N)           |
| AVL Tree       | AVL Tree          | O(logN)    | O(logN) | O(logN)               | O(N)       | 균형 엄격, 탐색 빠름              |
| Red-Black Tree | Red-Black Tree    | O(logN)    | O(logN) | O(logN)               | O(N)       | 느슨 균형, 삽입/삭제 효율           |
| B-Tree         | B-Tree            | O(logN)    | O(logN) | O(logN)               | O(N)       | M-way 트리, 디스크 최적          |
| Trie           | Trie              | O(L)       | O(L)    | O(L)                  | O(N \* L)  | 문자열 길이 기준 탐색, 접두사 탐색 최적   |
| 힙 (Heap)       | 힙 (Heap)          | O(logN)    | O(logN) | O(1) (Top)            | O(N)       | 우선순위 큐, Top 빠름, 전체 탐색 비효율 |
| 해시 탐색          | Hash Table        | O(1) 평균    | O(1) 평균 | O(1) 평균               | O(N)       | 키값 매칭 최적, 충돌 시 O(N)       |
| 슬라이딩 윈도우       | Deque             | O(1)       | O(1)    | O(1) (Front/Back)     | O(N)       | 구간 유지 최적화, 최대/최소 유지       |
| 선형 탐색          | 배열, 리스트           | O(N)       | O(N)    | O(N)                  | O(N)       | 순차 탐색, 정렬 불필요             |
| KMP            | 문자열 (패턴 매칭)       | O(M) (pre) | -       | O(N + M)              | O(M)       | 실패 테이블, 항상 O(N + M)       |
| Rabin-Karp     | 문자열 (해시 기반)       | O(1)       | -       | O(N + M) 평균, O(NM) 최악 | O(1)       | 해시 기반, 충돌 가능              |
| Aho-Corasick   | Trie + 실패 링크      | O(총 패턴 길이) | -       | O(N + 총 패턴 길이)        | O(총 패턴 길이) | 다중 패턴, Trie + 실패 링크       |
| BFS            | Queue             | O(1)       | O(1)    | O(1)                  | O(N)       | 그래프 탐색 기본, 너비 우선          |
| DFS            | Stack             | O(1)       | O(1)    | O(1)                  | O(N)       | 그래프 탐색 기본, 깊이 우선          |
| Dijkstra       | 힙 (Heap) + 인접 리스트 | O(logV)    | O(logV) | O(1) (Top)            | O(V + E)   | 최단 거리, 최소 힙 사용            |
| A\* (A Star)   | 힙 (Heap) + 인접 리스트 | O(logV)    | O(logV) | O(1) (Top)            | O(V + E)   | 휴리스틱 기반 최단 경로             |

# 동적/정적 or 복수 케이스가 존재하는 자료구조/알고리즘 구분 정리
| 알고리즘 / 자료구조               | 구분 포인트                                 | 케이스 A (정적/일반/낙관적) | 케이스 B (동적/최악/엄격)        | 키워드 / 특징                             |
| ------------------------- | -------------------------------------- | ----------------- | ----------------------- | ------------------------------------ |
| **배열 (Array)**            | 고정 크기 vs 동적 크기                         | Array (고정)        | Vector (동적 배열)          | Vector는 끝 삽입 Amortized O(1), 중간 O(N) |
| **이진 탐색 트리 (BST)**        | 균형 유지 여부                               | 일반 BST (비균형 가능)   | AVL Tree, RB Tree       | 일반 BST 최악 O(N), AVL/RB 항상 O(logN)    |
| **Heap**                  | 전체 탐색 여부                               | Top 접근 O(1)       | 전체 순회 O(N logN)         | Top만 빠름, 전체 탐색은 N \* logN 필요         |
| **Hash Table**            | 충돌 여부                                  | 평균 O(1)           | 최악 O(N)                 | 해시 충돌 시 최악 O(N), 체이닝/개방 주소법          |
| **Rabin-Karp**            | 해시 충돌 여부                               | 평균 O(N + M)       | 최악 O(NM)                | 해시 충돌 시 최악 시간 발생 가능                  |
| **Dijkstra / A\***        | 구현 방식 (배열 vs 힙)                        | 배열 사용 시 O(V^2)    | 최소 힙 사용 시 O(E + V logV) | 힙 기반 사용 시 최적화 가능                     |
| **슬라이딩 윈도우 (with Deque)** | 구간 크기 고정 vs 가변                         | 고정 크기 (O(N))      | 가변 크기 (투포인터 O(N))       | 고정 구간 슬윈, 가변 구간 Two Pointer          |
| **B-Tree / B+ Tree**      | B-Tree (내부/리프 혼합) vs B+ Tree (리프만 데이터) | B-Tree            | B+ Tree                 | 리프 노드에만 데이터 저장 (B+ Tree), 순차 접근 최적   |
| **KMP**                   | -                                      | 항상 O(N + M)       | 없음                      | 항상 안정 O(N + M)                       |
| **Trie**                  | -                                      | 항상 O(L)           | 없음                      | 접두사 탐색 최적                            |

# 정리 요점
✔ 배열 vs Vector → Vector만 동적 확장 O(1) Amortized

✔ BST는 균형 여부에 따라 O(N) ↔ O(logN)

✔ Heap은 Top만 빠르고 전체 탐색은 느림

✔ Hash Table, Rabin-Karp는 충돌 발생 시 최악 O(N) 가능

✔ Dijkstra, A*는 힙 사용 시 최적화, 배열 사용 시 비효율

✔ 슬라이딩 윈도우도 고정/가변에 따라 Two Pointer로 분리 가능

✔ B-Tree는 리프 데이터 여부에 따라 B+ Tree로 구분

✔ KMP, Trie는 안정적인 복잡도, 예외 없음
