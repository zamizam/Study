## 옵저버 패턴(Observer Pattern)
**면접을 위한 CS 전문 지식 노트**

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메소드 등을 통해 옵저버 목록에 있는 옵저버 들에게 변화를 알려주는 디자인 패턴이다.

주체는 객체의 상태 변화를 보고 있는 관찰자다. 

1. 옵저버들은 이 객체의 상태 변화에 따라 전달되는 메소드 등을 기반으로 추가 변화 사항이 생기는 객체들을 의미한다.
2. 주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도 한다.

옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 [MVC(Model-View-Controller) 패턴](https://github.com/zamizam/Study/blob/main/DesignPatterns/MVC%ED%8C%A8%ED%84%B4.md)에도 사용된다.

**게임 프로그래밍 패턴**
객체 사이에 일대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 업데이트될 수 있게 만드는 패턴이다.

예를 들어, 알람 메소드가 관찰당하는 객체가 호출하게 되는데, 이런 객체를 '대상(Suject)라고 부른다.

대상의 역할은<br/>
1. 알람을 끈질기게 기다리는 관찰자 목록을 들고 있는다.<br/>
알람 메소드는 누가 알림을 받을 것인지 제어할 수 있기 때문에, 대상은 관찰자와 상호작용은 하지만 서로 커플링되어 있지는 않다. <br/>
대상이 관찰자를 여러 개 목록으로 관리하여 관찰자들은 서로 커플링되지 않게 된다.

2. 알림을 보내는 것이다. 

#### 주의해야 할 점
관찰자 패턴은 동기적이다.

대상이 관찰자 메소드를 직접 호출하기 때문에 모든 관찰자가 알림 메소드를 반환하기 전에는 다음 작업을 진행할 수 없다.<br/>
관찰자 중 하나라도 느리면 대상이 블록될 수 있다.

특히나, UI 같은 경우에 이벤트 기반 프로그래밍을 하기 때문에 이벤트에 동기적으로 반응한다면 최대한 빨리 작업을 끝내고 제어권을 다시 넘겨줘야한다.

작업이 오래 걸릴 경우, 다른 스레드에 넘기거나 작업 큐를 활용해야 한다.

관찰자를 멀티스레드와 lock()과 함께 사용한다면 어떤 관찰자가 대상의 락을 물고 있다면 게임 전체가 교착상태에 빠질 수 있다.

이의 해결책으로 이벤트 큐를 이용해 비동기적으로 상호작용하는 방법이 있다.


